import library/maybe
import library/fn
import library/list


def Functor (F : Type -> Type) : Type^1 = (A B : Type) -> (A -> B) -> F A -> F B

def Applicative (F : Type -> Type) : Type^1 =
  (pure : (A : Type) -> A -> F A) *
  (<*> : (A B : Type) -> F (A -> B) -> F A -> F B) *
  Functor F

def Monad (F : Type -> Type) : Type^1 = 
  (join : (A : Type) -> F (F A) -> F A) *
  Applicative F


def bind (F : Type -> Type) (M : Monad F) (A B : Type) (m : F A) (f : A -> F B) : F B =
  M.1 B (M.2.2.2 A (F B) f m)

def Functor-id : Functor (\ A => A) = \ _ _ f => f

def Applicative-id : Applicative (\ A => A) = (id,Functor-id,Functor-id)

def Monad-id : Monad (\ A => A) = (id,Applicative-id)

def Functor-Maybe : Functor Maybe = \ A B f => \elim
  | none => none
  | some x => some (f x)

def Applicative-Maybe : Applicative Maybe =
  (\ _ x => some x,\ _ _ => \elim none => \ _ => none | some f => \elim none => none | some x => some (f x),Functor-Maybe)

def Monad-Maybe : Monad Maybe =
  (\ _ => \elim none => none | some x => x,Applicative-Maybe)

def Functor-List : Functor List = \ A B f => \elim
  | nil => nil
  | cons x (xs / ih) => cons (f x) ih

def Applicative-List : Applicative List = 
  ( \ _ x => cons x nil
  , \ A B fs xs => elim fs with
    | nil => nil
    | cons f (fs / ih) => ++ B (map A B f xs) ih
  , Functor-List
  )

def Monad-List : Monad List =
  ( \ A => \elim
    | nil => nil
    | cons x (_ / ih) => ++ A x ih
  , Applicative-List
  )

def Functor-NotNot : Functor (\ A => Not (Not A)) =
  \ A B f ~~a ~b => ~~a (\ a => ~b (f a))

def Applicative-NotNot : Applicative (\ A => Not (Not A)) =
  ( \ A a ~a => ~a a
  , \ A B ~~A->B ~~a ~b => ~~A->B (\ f => ~~a (\ a => ~b (f a)))
  , Functor-NotNot
  )

def Monad-NotNot : Monad (\ A => Not (Not A)) =
  ( \ A ~~~~a ~a => ~~~~a (\ ~~a => ~~a ~a)
  , Applicative-NotNot
  )
