
def J (A : Type) (P : (x y : A) -> Id A x y -> Type) (f : (x : A) -> P x x refl) (x y : A) (p : Id A x y) : P x y p =
  match p with
    | refl i => f i

axiom K : (A : Type) (x : A) (P : Id A x x -> Type) (r : P refl) (p : Id A x x) -> P p

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p with
    | refl x => refl

def trans (A : Type) (x y z : A) (p : Id A x y) : Id A y z -> Id A x z =
  match p with
    | refl _ => fn x => x

def cong (A B : Type) (f : A -> B) (x y : A) (p : Id A x y) : Id B (f x) (f y) =
  match p with
    | refl _ => refl

def subst (A : Type) (x y : A) (p : Id A x y) (P : A -> Type) : P x -> P y =
  match p with
    | refl _ => fn z => z

def coe (A B : Type) (p : Id Type A B) : A -> B =
  match p with
    | refl _ => Î» x => x

def trans-refl (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x y y p refl) =
  match p with
    | refl _ => refl

def refl-trans (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x x y refl p) =
  match p with
    | refl _ => refl

def sym-sym (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (sym A y x (sym A x y p)) =
  match p with
    | refl _ => refl

def sym-inverse (A : Type) (x y : A) (p : Id A x y) : Id (Id A y y) refl (trans A y x y (sym A x y p) p) =
  match p with
    | refl i => refl

def sym-refl (A : Type) (x : A) : Id (Id A x x) refl (sym A x x refl) =
  refl

def trans-assoc (A : Type) (a b c d : A) (p : Id A a b) : (q : Id A b c) (h : Id A c d) -> Id (Id A a d) (trans A a c d (trans A a b c p q) h) (trans A a b d p (trans A b c d q h)) =
  match p with
    | refl i => fn q => match q with
      | refl j => fn h => refl

def coe-refl (A : Type) (x : A) : Id A (coe A A refl x) x = refl

def coe-trans (A B C : Type) (p : Id Type A B) : (q : Id Type B C) (x : A) -> Id C (coe B C q (coe A B p x)) (coe A C (trans^1 Type A B C p q) x) =
  match p with
    | refl I => fn _ _ => refl

def pair-ext (A B : Type) (x y : A * B) (p : Id A x.1 y.1) (q : Id B x.2 y.2) : Id (A * B) x y =
  match p with
    | refl w => match q with
      | refl h => refl

def pair-id-l (A B : Type) (x y : A * B) (p : Id (A * B) x y) : Id A x.1 y.1 =
  cong (A * B) A (fn x => x.1) x y p

def pair-id-r (A B : Type) (x y : A * B) (p : Id (A * B) x y) : Id B x.2 y.2 =
  cong (A * B) B (fn x => x.2) x y p

