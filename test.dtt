def id (A : Type) (x : A) : A = x

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p at x y _ => Id A y x with
    | refl _ => refl

def trans (A : Type) (x y z : A) (p : Id A x y) (q : Id A y z) : Id A x z =
  (match p at x y _ => Id A y z -> Id A x z with
     | refl _ => λ eq => eq) q

def subst (A : Type) (x y : A) (p : Id A x y) (P : A -> Type) : P x -> P y =
  match p at x y _ => P x -> P y with
    | refl _ => fn z => z

def coe (A B : Type) (p : Id Type A B) : A -> B =
  match p at A B _ => A -> B with
    | refl _ => λ x => x

data Void = |

def Void-Ind (P : Void -> Type) : (x : Void) -> P x =
  elim with

def not (A : Type) : Type = A -> Void

data Unit =
  | <>

def Unit-Ind (P : Unit -> Type) (p : P <>) : (x : Unit) -> P x =
  elim with
    | <> => p

def Unit-Eta : (x : Unit) -> Id Unit x <> = 
  elim with
    | <> => refl

def Unit-not-Void (p : Id Type Unit Void) : Void =
  coe Unit Void p <>

data Bool =
  | tt
  | ff

def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) : (b : Bool) -> P b =
  elim with
    | tt => t
    | ff => f

def not : Bool -> Bool =
  elim with
    | tt => ff
    | ff => tt

def and : Bool -> Bool -> Bool =
  elim with
    | tt => fn b => b
    | ff => fn _ => ff

def or : Bool -> Bool -> Bool =
  elim with
    | tt => fn _ => tt
    | ff => fn b => b

def not-not : (b : Bool) -> Id Bool b (not (not b)) =
  elim with
    | tt => refl
    | ff => refl

def demorgan1 : (p q : Bool) -> Id Bool (not (and p q)) (or (not p) (not q)) =
  elim with
    | tt => fn _ => refl
    | ff => fn _ => refl

def demorgan2 : (p q : Bool) -> Id Bool (not (or p q)) (and (not p) (not q)) =
  elim with
    | tt => fn _ => refl
    | ff => fn _ => refl

data Nat =
  | zero
  | suc (n : Nat)

def one : Nat = suc zero
def two : Nat = suc (suc zero)

def Nat-Ind (P : Nat -> Type) (z : P zero) (s : (m : Nat) -> P m -> P (suc m)) : (n : Nat) -> P n =
  elim with
    | zero => z
    | suc (n' / ih) => s n' ih


def pred : Nat -> Nat =
  elim with
    | zero => zero
    | suc n => n

def + : Nat -> Nat -> Nat =
  elim with
    | zero => fn m => m
    | suc (_ / ih) => fn m => suc (ih m)

def * : Nat -> Nat -> Nat =
  elim with
    | zero => fn _ => zero
    | suc (n / ih) => fn m => + m (ih m)

def +-assoc : (n m p : Nat) -> Id Nat (+ (+ n m) p) (+ n (+ m p)) =
  elim with
    | zero => fn _ _ => refl
    | suc (n' / ih) => fn m p =>
      match ih m p at x y _ => Id Nat (suc x) (suc y) with
        | refl z => refl

def +-zero : (n : Nat) -> Id Nat n (+ n zero) =
  elim with
    | zero => refl
    | suc (n' / ih) => 
      match ih at x y _ => Id Nat (suc x) (suc y) with
        | refl x => refl

def +-suc : (n m : Nat) -> Id Nat (suc (+ n m)) (+ n (suc m)) =
  elim with
    | zero => fn _ => refl
    | suc (n' / ih) => fn m =>
      match ih m at x y _ => Id Nat (suc x) (suc y) with
        | refl x => refl


data List =
  | nil
  | cons (x : Nat) (xs : List)

def List-Ind (P : List -> Type) (n : P nil) (c : (n : Nat) (xs : List) -> P xs -> P (cons n xs)) : (xs : List) -> P xs =
  elim with
    | nil => n
    | cons x (xs / ih) => c x xs ih

def ++ : List -> List -> List =
  elim with
    | nil => fn ys => ys
    | cons x (_ / ih) => fn ys => cons x (ih ys)


def xs : List = cons zero (cons one nil)

data Exp =
  | num (n : Nat)
  | add (m n : Exp) 
  | mul (m n : Exp)

def eval : Exp -> Nat =
  elim with
    | num n => n
    | add (_ / ih1) (_ / ih2) => + ih1 ih2
    | mul (_ / ih1) (_ / ih2) => * ih1 ih2

def e : Exp = mul (add (num one) (num one)) (num two)

data Tree =
  | empty
  | node (l : Tree) (x : Nat) (r : Tree)

def tree-rev : Tree -> Tree =
  elim with
    | empty => empty
    | node (l / ihl) x (r / ihr) => node ihr x ihl

