def id (A : Type) (x : A) : A = x


def J (A : Type) (P : (x y : A) -> Id A x y -> Type) (f : (x : A) -> P x x refl) (x y : A) (p : Id A x y) : P x y p =
  match p with
    | refl i => f i

axiom K : (A : Type) (x : A) (P : Id A x x -> Type) (r : P refl) (p : Id A x x) -> P p

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p with
    | refl _ => refl

def trans (A : Type) (x y z : A) (p : Id A x y) : Id A y z -> Id A x z =
  match p with
    | refl _ => fn x => x

def cong (A B : Type) (f : A -> B) (x y : A) (p : Id A x y) : Id B (f x) (f y) =
  match p with
    | refl _ => refl

def subst (A : Type) (x y : A) (p : Id A x y) (P : A -> Type) : P x -> P y =
  match p with
    | refl _ => fn z => z

def coe (A B : Type) (p : Id Type A B) : A -> B =
  match p with
    | refl _ => Î» x => x

def trans-refl (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x y y p refl) =
  match p with
    | refl _ => refl

def refl-trans (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x x y refl p) =
  match p with
    | refl _ => refl

def sym-sym (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (sym A y x (sym A x y p)) =
  match p with
    | refl _ => refl

def coe-refl (A : Type) (x : A) : Id A (coe A A refl x) x = refl


def Comm (A : Type) (op : A -> A -> A) : Type = (x y : A) -> Id A (op x y) (op y x)

def Assoc (A : Type) (op : A -> A -> A) : Type = (x y z : A) -> Id A (op (op x y) z) (op x (op y z))

def Id-L (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op z x)

def Id-R (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op x z)


def curry (A B C : Type) (f : A * B -> C) : A -> B -> C = fn x y => f (x,y)
def curryd (A : Type) (B : A -> Type) (C : (x : A) -> B x -> Type) (f : (p : (x : A) * B x) -> C p.1 p.2) : (x : A) (y : B x) -> C x y = fn x y => f (x,y)

def uncurry (A B C : Type) (f : A -> B -> C) : A * B -> C = fn p => f p.1 p.2
def uncurryd (A : Type) (B : A -> Type) (C : (x : A) -> B x -> Type) (f : (x : A) (y : B x) -> C x y) : (p : (x : A) * B x) -> C p.1 p.2 = fn p => f p.1 p.2

data Void = |

def Void-Ind (P : Void -> Type) : (x : Void) -> P x =
  elim with

def Not (A : Type) : Type = A -> Void

data Unit =
  | <>

def Unit-Ind (P : Unit -> Type) (p : P <>) : (x : Unit) -> P x = elim with
  | <> => p

def Unit-Eta : (x : Unit) -> Id Unit <> x = elim with
  | <> => refl


data Bool =
  | tt
  | ff

def no-confusion-Bool : Not (Id Bool tt ff) = fn p =>
  subst Bool tt ff p (elim with tt => Unit | ff => Void) <>

def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) : (b : Bool) -> P b = elim with
  | tt => t
  | ff => f

def not : Bool -> Bool = elim with
  | tt => ff
  | ff => tt


def and (a b : Bool) : Bool = elim a with
  | tt => b
  | ff => ff

def or (a b : Bool) : Bool = elim a with
  | tt => tt
  | ff => b


def not-not : (b : Bool) -> Id Bool b (not (not b)) = elim with
  | tt => refl
  | ff => refl

def demorgan1 (a b : Bool) : Id Bool (not (and a b)) (or (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

def demorgan2 (a b : Bool) : Id Bool (not (or a b)) (and (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

data Nat =
  | zero
  | suc (n : Nat)

def one : Nat = suc zero
def two : Nat = suc one
def three : Nat = suc two
def four : Nat = suc three

def Nat-Ind (P : Nat -> Type) (z : P zero) (s : (m : Nat) -> P m -> P (suc m)) : (n : Nat) -> P n = elim with
  | zero => z
  | suc (n / ih) => s n ih

def no-confusion-Nat (n : Nat) : Not (Id Nat zero (suc n)) = fn p =>
  subst Nat zero (suc n) p (elim with zero => Unit | suc _ => Void) <>

def pred : Nat -> Nat = elim with
  | zero => zero
  | suc n => n

def + (n m : Nat) : Nat = elim n with
  | zero => m
  | suc (_ / ih) => suc ih

def mult (n m : Nat) : Nat = elim n with
  | zero => zero
  | suc (_ / ih) => + m ih


def +-assoc : Assoc Nat + = fn n m p => elim n with
  | zero => refl
  | suc (_ / ih) => match ih with
    | refl _ => refl

def +-zero : Id-R Nat + zero = elim with
  | zero => refl
  | suc (_ / ih) => match ih with
      | refl _ => refl

def +-suc (n m : Nat) : Id Nat (suc (+ n m)) (+ n (suc m)) = elim n with
  | zero => refl
  | suc (n' / ih) => 
    match ih with
      | refl z => refl

def +-comm : Comm Nat + = fn n m => elim n with
  | zero => +-zero m
  | suc (n / ih) => trans Nat (suc (+ n m)) (suc (+ m n)) (+ m (suc n)) 
    (cong Nat Nat (fn x => suc x) (+ n m) (+ m n) ih) 
    (+-suc m n)


def leq : Nat -> Nat -> Type = elim with
  | zero => fn _ => Unit
  | suc (_ / ih) => elim with
    | zero => Void
    | suc n => ih n

def leq-zero (n : Nat) : leq zero n = <>
def leq-suc (m n : Nat) (p : leq m n) : leq (suc m) (suc n) = p



def id-elim : Nat -> Nat = elim with
  | zero => zero
  | suc n => suc n

def id-elim-id : (n : Nat) -> Id Nat (id Nat n) (id-elim n) = elim with
  | zero => refl
  | suc _ => refl

def suc-Inj (n m : Nat) : Id Nat (suc n) (suc m) -> Id Nat n m =
  cong Nat Nat pred (suc n) (suc m)


data Maybe =
  | none
  | some (x : Nat)

data List =
  | nil
  | cons (x : Nat) (xs : List)

def List-Ind (P : List -> Type) (n : P nil) (c : (n : Nat) (xs : List) -> P xs -> P (cons n xs)) : (xs : List) -> P xs = elim with
  | nil => n
  | cons x (xs / ih) => c x xs ih

def ++ (xs ys : List) : List = elim xs with
  | nil => ys
  | cons x (_ / ih) => cons x ih

def hd : List -> Maybe = elim with
  | nil => none
  | cons x _ => some x

def tl : List -> List = elim with
  | nil => nil
  | cons _ xs => xs

def ++-assoc : Assoc List ++ = fn xs ys zs => elim xs with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl

def ++-nil : Id-R List ++ nil = elim with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl


data Tree =
  | empty
  | node (l : Tree) (x : Nat) (r : Tree)

def tree-rev : Tree -> Tree = elim with
  | empty => empty
  | node (l / ihl) x (r / ihr) => node ihr x ihl

def Iso (A B : Type) : Type^1 =
  (f : A -> B) *
  (g : B -> A) *
  ((x : A) -> Id A x (g (f x))) *
  ((y : B) -> Id B y (f (g y)))

def PType : Type^1 = (A : Type) * A

def PUnit : PType = (Unit,<>)
def PNat : PType = (Nat,zero)

def Loop (P : PType) : PType =
  (Id P.1 P.2 P.2, refl)

def LoopN (P : PType) : Nat -> PType = elim with
  | zero => P
  | suc (_ / ih) => Loop ih

def PType-not-Void (P : PType) : Not^1 (Id Type P.1 Void) = fn p =>
  coe P.1 Void p P.2

def pair-ext (A B : Type) (x y : A * B) (p : Id A x.1 y.1) (q : Id B x.2 y.2) : Id (A * B) x y =
  match p with
    | refl w => match q with
      | refl h => refl

def Vec (A : Type) : Nat -> Type = elim with
  | zero => Unit
  | suc (_ / ih) => A * ih

def vnil (A : Type) : Vec A zero = <>
def vcons (A : Type) (x : A) (n : Nat) (xs : Vec A n) : Vec A (suc n) = (x,xs)

def vhd (A : Type) (n : Nat) (v : Vec A (suc n)) : A = v.1
def vtl (A : Type) (n : Nat) (v : Vec A (suc n)) : Vec A n = v.2

def Vec-Ind (A : Type) (P : (n : Nat) -> Vec A n -> Type) (b : P zero <>) 
            (c : (m : Nat) (v : Vec A m) (x : A) -> P m v -> P (suc m) (x,v)) : (n : Nat) (v : Vec A n) -> P n v = elim with
  | zero => (elim with <> => b)
  | suc (n / ih) => fn v => c n v.2 v.1 (ih v.2) 

def vrec (A B : Type) (b : B) (c : A -> B -> B) : (n : Nat) -> Vec A n -> B = elim with
  | zero => fn _ => b
  | suc (n / ih) => fn v => c v.1 (ih v.2)


def vzip (A B : Type) : (n : Nat) -> Vec A n -> Vec B n -> Vec (A * B) n = elim with
  | zero => fn _ _ => <>
  | suc (_ / ih) => fn v1 v2 => ((v1.1,v2.1),ih v1.2 v2.2)

def sumty (A B : Type) : Bool -> Type = elim with tt => A | ff => B

def Sum (A B : Type) : Type = (b : Bool) * sumty A B b
def inl (A B : Type) (x : A) : Sum A B = (tt,x)
def inr (A B : Type) (x : B) : Sum A B = (ff,x)


data SumNatBool =
  | in1 (n : Nat)
  | in2 (b : Bool)

def iso/Sum : Iso (Sum Nat Bool) (SumNatBool) = 
  let f = uncurryd Bool (sumty Nat Bool) (fn _ _ => SumNatBool) (elim with tt => fn x => in1 x | ff => fn x => in2 x) in
  let g : SumNatBool -> Sum Nat Bool = elim with in1 x => (tt,x) | in2 x => (ff,x) in
  let fg : (s : SumNatBool) -> Id SumNatBool s (f (g s)) = elim with in1 x => refl | in2 x => refl in
  let gf = uncurryd Bool (sumty Nat Bool) (fn x1 x2 => Id (Sum Nat Bool) (x1,x2) (g (f (x1,x2)))) 
    (elim with tt => fn n => refl | ff => fn n => refl) in
  ( f 
  , g
  , gf
  , fg
  )




def Monoid (M : Type) : Type =
  (z : M) *
  (op : M -> M -> M) *
  Id-L M op z *
  Id-R M op z *
  Assoc M op

def Monoid-Nat-+ : Monoid Nat =
  ( zero
  , +
  , fn _ => refl
  , +-zero
  , +-assoc
  )

def Monoid-List-++ : Monoid List =
  ( nil
  , ++
  , fn _ => refl
  , ++-nil
  , ++-assoc
  )



data U =
  | arrow (e1 e2 : U)
  | nat | bool

def El : U -> Type = elim with
  | arrow (_ / t1) (_ / t2) => t1 -> t2
  | nat => Nat
  | bool => Bool

data Exp =
  | num (n : Nat)
  | add (m n : Exp) 

def eval : Exp -> Nat = elim with
  | num n => n
  | add (_ / ih1) (_ / ih2) => + ih1 ih2

def eval-tail' : Exp -> Nat -> Nat = elim with
  | num n => fn acc => + n acc
  | add (n / ih1) (m / ih2) => fn acc => ih1 (ih2 acc) 

def eval-tail : Exp -> Nat = fn e => eval-tail' e zero


def Contr (A : Type) : Type = (x : A) * (y : A) -> Id A x y

def Prop (A : Type) : Type = (x y : A) -> Id A x y

def Set (A : Type) : Type = (x y : A) -> Prop (Id A x y)

def HLevel : Nat -> Type -> Type = elim with
  | zero  => Contr
  | suc n => elim n with
    | zero => Prop
    | suc (_ / ih) => fn A => (x y : A) -> ih (Id A x y)



{-
def HLevel-suc (A : Type) : (n : Nat) -> HLevel n A -> HLevel (suc n) A = elim with
  | zero => fn p x y => trans A x p.1 y (sym A p.1 x (p.2 x)) (p.2 y)
  | suc n => elim n with
    | zero => fn f x y p q => 
      let id-point = f x in
      ?
    | suc (_ / ih) => ?
-}

def Contr-Unit : Contr Unit = (<>,Unit-Eta)

def Prop-Unit : Prop Unit = elim with 
  | <> => elim with <> => refl

def Set-Unit : Set Unit = elim with <> => elim with <> => fn p =>
  let P1 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn p => (q : Id Unit <> <>) -> Id (Id Unit <> <>) p q in
  let P2 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn q => Id (Id Unit <> <>) refl q in
  match p at x y p => P1 x y p with
    | refl i => elim i with <> => fn q => 
      match q at x y q => P2 x y q with
        | refl j => elim j with <> => refl

def Prop-Void : Prop Void = elim with

def Set-Void : Set Void = elim with

def HLevel-suc-Void : (n : Nat) -> HLevel (suc n) Void = elim with
  | zero  => (elim with)
  | suc n => (elim with)


def Singl (A : Type) (x : A) : Type = (y : A) * Id A x y

def Contr-Singl (A : Type) (x : A) : Contr (Singl A x) = 
  ((x,refl),fn p => match p.2 with refl w => refl)

axiom funext : (A B : Type) (f g : A -> B) -> ((x : A) -> Id B (f x) (g x)) -> Id (A -> B) f g

axiom ua : (A B : Type) -> Iso A B -> Id Type A B

def Functor (F : Type -> Type) : Type^1 = (A B : Type) -> (A -> B) -> F A -> F B

def Applicative (F : Type -> Type) : Type^1 =
  (pure : (A : Type) -> A -> F A) *
  (<*> : (A B : Type) -> F (A -> B) -> F A -> F B) *
  Functor F

def Monad (F : Type -> Type) : Type^1 = 
  (join : (A : Type) -> F (F A) -> F A) *
  Applicative F


def bind (F : Type -> Type) (M : Monad F) (A B : Type) (m : F A) (f : A -> F B) : F B =
  M.1 B (M.2.2.2 A (F B) f m)
