def id (A : Type) (x : A) : A = x

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p at x y _ => Id A y x with
    | refl z => refl

def trans (A : Type) (x y z : A) (p : Id A x y) (q : Id A y z) : Id A x z =
  (match p at x y _ => Id A y z -> Id A x z with
     | refl x => Î» eq => eq) q

data Unit =
  | <>

def Unit-Ind (P : Unit -> Type) (p : P <>) (x : Unit) : P x =
  elim x at x => P x with
    | <> => p

def Unit-Eta (x : Unit) : Id Unit x <> = 
  elim x at x => Id Unit x <> with
    | <> => refl

data Nat =
  | zero
  | suc (n : Nat)

def one : Nat = suc zero
def two : Nat = suc (suc zero)

def Nat-Ind (P : Nat -> Type) (z : P zero) (s : (m : Nat) -> P m -> P (suc m)) (n : Nat) : P n =
  elim n at x => P x with
    | zero => z
    | suc (n' / ih) => s n' ih

def + (n m : Nat) : Nat =
  elim n at _ => Nat with
    | zero => m
    | suc (_ / ih) => suc ih

def +-zero (n : Nat) : Id Nat (+ n zero) n =
  elim n at n => Id Nat (+ n zero) n with
    | zero => refl
    | suc (n' / ih) => 
      match ih at x y _ => Id Nat (suc x) (suc y) with
        | refl x => refl

data List =
  | nil
  | cons (x : Nat) (xs : List)

def List-Ind (P : List -> Type) (n : P nil) (c : (n : Nat) (xs : List) -> P xs -> P (cons n xs)) (xs : List) : P xs =
  elim xs at x => P x with
    | nil => n
    | cons x (xs / ih) => c x xs ih

def ++ (xs ys : List) : List =
  elim xs at _ => List with
    | nil => ys
    | cons x (_ / ih) => cons x ih

def xs : List = cons zero (cons one nil)

data Sg =
  | pair (A : Type) (B : A -> Type) (fst : A) (snd : B fst)
