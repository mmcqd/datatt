def id (A : Type) (x : A) : A = x

def J (A : Type) (P : (x y : A) -> Id A x y -> Type) (f : (x : A) -> P x x refl) (x y : A) (p : Id A x y) : P x y p =
  match p with
    | refl i => f i

axiom K : (A : Type) (x : A) (P : Id A x x -> Type) (r : P refl) (p : Id A x x) -> P p

axiom funext : (A B : Type) (f g : A -> B) -> ((x : A) -> Id B (f x) (g x)) -> Id (A -> B) f g

axiom funextd : (A : Type) (B : A -> Type) (f g : (x : A) -> B x) -> ((x : A) -> Id (B x) (f x) (g x)) -> Id ((x : A) -> B x) f g

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p with
    | refl _ => refl

def trans (A : Type) (x y z : A) (p : Id A x y) : Id A y z -> Id A x z =
  match p with
    | refl _ => fn x => x

def cong (A B : Type) (f : A -> B) (x y : A) (p : Id A x y) : Id B (f x) (f y) =
  match p with
    | refl _ => refl

def subst (A : Type) (x y : A) (p : Id A x y) (P : A -> Type) : P x -> P y =
  match p with
    | refl _ => fn z => z

def coe (A B : Type) (p : Id Type A B) : A -> B =
  match p with
    | refl _ => Î» x => x

def trans-refl (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x y y p refl) =
  match p with
    | refl _ => refl

def refl-trans (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x x y refl p) =
  match p with
    | refl _ => refl

def sym-sym (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (sym A y x (sym A x y p)) =
  match p with
    | refl _ => refl

def coe-refl (A : Type) (x : A) : Id A (coe A A refl x) x = refl


def Comm (A : Type) (op : A -> A -> A) : Type = (x y : A) -> Id A (op x y) (op y x)

def Assoc (A : Type) (op : A -> A -> A) : Type = (x y z : A) -> Id A (op (op x y) z) (op x (op y z))

def Id-L (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op z x)

def Id-R (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op x z)


def curry (A B C : Type) (f : A * B -> C) : A -> B -> C = fn x y => f (x,y)
def curryd (A : Type) (B : A -> Type) (C : (x : A) -> B x -> Type) (f : (p : (x : A) * B x) -> C p.1 p.2) : (x : A) (y : B x) -> C x y = fn x y => f (x,y)

def uncurry (A B C : Type) (f : A -> B -> C) : A * B -> C = fn p => f p.1 p.2
def uncurryd (A : Type) (B : A -> Type) (C : ((x : A) * B x) -> Type) (f : (x : A) (y : B x) -> C (x,y)) : (p : (x : A) * B x) -> C p = fn p => f p.1 p.2

data Void

def Void-Ind (P : Void -> Type) : (x : Void) -> P x =
  elim with

def Not (A : Type) : Type = A -> Void

data Unit =
  | <>

def Unit-Ind (P : Unit -> Type) (p : P <>) : (x : Unit) -> P x = elim with
  | <> => p

def Unit-Eta : (x : Unit) -> Id Unit <> x = elim with
  | <> => refl


data Bool =
  | tt
  | ff


{- The traditional proof that tt != ff -}
def no-confusion-Bool : Not (Id Bool tt ff) = fn p =>
  subst Bool tt ff p (elim with tt => Unit | ff => Void) <>

{- Some syntactic sugar, which we know is consistent because the above proof is possible -}
def no-confusion-Bool : Not (Id Bool tt ff) = fn ()


def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) : (b : Bool) -> P b = elim with
  | tt => t
  | ff => f

def not : Bool -> Bool = elim with
  | tt => ff
  | ff => tt


def and (a b : Bool) : Bool = elim a with
  | tt => b
  | ff => ff

def or (a b : Bool) : Bool = elim a with
  | tt => tt
  | ff => b


def not-not : (b : Bool) -> Id Bool b (not (not b)) = elim with
  | tt => refl
  | ff => refl

def demorgan1 (a b : Bool) : Id Bool (not (and a b)) (or (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

def demorgan2 (a b : Bool) : Id Bool (not (or a b)) (and (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

def lift : Bool -> Type = elim with
  | tt => Unit
  | ff => Void


data Nat =
  | zero
  | suc (n : Nat)

def one : Nat = suc zero
def two : Nat = suc one
def three : Nat = suc two
def four : Nat = suc three

def Nat-Ind (P : Nat -> Type) (z : P zero) (s : (m : Nat) -> P m -> P (suc m)) : (n : Nat) -> P n = elim with
  | zero => z
  | suc (n / ih) => s n ih

def no-confusion-Nat (n : Nat) : Not (Id Nat zero (suc n)) = fn ()

def pred : Nat -> Nat = elim with
  | zero => zero
  | suc n => n

def + (n m : Nat) : Nat = elim n with
  | zero => m
  | suc (_ / ih) => suc ih

def mult (n m : Nat) : Nat = elim n with
  | zero => zero
  | suc (_ / ih) => + m ih

def exp (n m : Nat) : Nat = elim m with
  | zero => one
  | suc (_ / ih) => mult n ih

def +-assoc : Assoc Nat + = fn n m p => elim n with
  | zero => refl
  | suc (_ / ih) => match ih with
    | refl _ => refl

def +-zero : Id-R Nat + zero = elim with
  | zero => refl
  | suc (_ / ih) => match ih with
      | refl _ => refl

def +-suc (n m : Nat) : Id Nat (suc (+ n m)) (+ n (suc m)) = elim n with
  | zero => refl
  | suc (n' / ih) => 
    match ih with
      | refl z => refl

def +-comm : Comm Nat + = fn n m => elim n with
  | zero => +-zero m
  | suc (n / ih) => trans Nat (suc (+ n m)) (suc (+ m n)) (+ m (suc n)) 
    (cong Nat Nat (fn x => suc x) (+ n m) (+ m n) ih) 
    (+-suc m n)


def leq : Nat -> Nat -> Type = elim with
  | zero => fn _ => Unit
  | suc (_ / ih) => elim with
    | zero => Void
    | suc n => ih n

def leq-zero (n : Nat) : leq zero n = <>
def leq-suc (m n : Nat) (p : leq m n) : leq (suc m) (suc n) = p

def even-b : Nat -> Bool = elim with
  | zero => tt
  | suc (n / ih) => not ih

def even (n : Nat) : Type = lift (even-b n)
 

def id-elim : Nat -> Nat = elim with
  | zero => zero
  | suc n => suc n

def id-elim-id : (n : Nat) -> Id Nat (id Nat n) (id-elim n) = elim with
  | zero => refl
  | suc _ => refl

def suc-Inj (n m : Nat) : Id Nat (suc n) (suc m) -> Id Nat n m =
  cong Nat Nat pred (suc n) (suc m)


data (A B : Type) Sum =
  | inl (x : A)
  | inr (y : B)

def Sum-Ind (A B : Type) (P : Sum A B -> Type) (l : (x : A) -> P (inl x)) (r : (x : B) -> P (inr x)) : (x : Sum A B) -> P x = elim with
  | inl x => l x
  | inr y => r y

data (A : Type) Maybe =
  | none
  | some (x : A)

data (A : Type) List =
  | nil
  | cons (x : A) (xs : List)

def List-Ind (A : Type) (P : List A -> Type) (n : P nil) (c : (x : A) (xs : List A) -> P xs -> P (cons x xs)) : (xs : List A) -> P xs = elim with
  | nil => n
  | cons x (xs / ih) => c x xs ih

def ++ (A : Type) (xs ys : List A) : List A = elim xs with
  | nil => ys
  | cons x (_ / ih) => cons x ih

def hd (A : Type) : List A -> Maybe A = elim with
  | nil => none
  | cons x _ => some x

def tl (A : Type) : List A -> List A = elim with
  | nil => nil
  | cons _ xs => xs

def ++-assoc (A : Type) : Assoc (List A) (++ A) = fn xs ys zs => elim xs with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl

def ++-nil (A : Type) : Id-R (List A) (++ A) nil = elim with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl

def map (A B : Type) (f : A -> B) : List A -> List B = elim with
  | nil => nil
  | cons x (xs / ih) => cons (f x) ih

def get (A : Type) : List A -> Nat -> Maybe A = elim with
  | nil => fn _ => none
  | cons x (xs / ih) => elim with
    | zero => some x
    | suc n => ih n 


data (A : Type) Tree =
  | empty
  | node (l : Tree) (x : A) (r : Tree)

def tree-rev (A : Type) : Tree A -> Tree A = elim with
  | empty => empty
  | node (l / ihl) x (r / ihr) => node ihr x ihl

def PType : Type^1 = (A : Type) * A

def UnitP : PType = (Unit,<>)
def NatP : PType = (Nat,zero)
def TypeP : PType^1 = (Type,Unit)
def TypePN : PType^2 = (Type^1,Type)


def Loop (P : PType) : PType =
  (Id P.1 P.2 P.2, refl)

def LoopN (P : PType) : Nat -> PType = elim with
  | zero => P
  | suc (_ / ih) => Loop ih

def PType-not-Void (P : PType) : Not^1 (Id Type P.1 Void) = fn p =>
  coe P.1 Void p P.2

def pair-ext (A B : Type) (x y : A * B) (p : Id A x.1 y.1) (q : Id B x.2 y.2) : Id (A * B) x y =
  match p with
    | refl w => match q with
      | refl h => refl

def pair-id-l (A B : Type) (x y : A * B) (p : Id (A * B) x y) : Id A x.1 y.1 =
  cong (A * B) A (fn x => x.1) x y p

def pair-id-r (A B : Type) (x y : A * B) (p : Id (A * B) x y) : Id B x.2 y.2 =
  cong (A * B) B (fn x => x.2) x y p

def Vec (A : Type) : Nat -> Type = elim with
  | zero => Unit
  | suc (_ / ih) => A * ih

def vnil (A : Type) : Vec A zero = <>
def vcons (A : Type) (x : A) (n : Nat) (xs : Vec A n) : Vec A (suc n) = (x,xs)

def vhd (A : Type) (n : Nat) (v : Vec A (suc n)) : A = v.1
def vtl (A : Type) (n : Nat) (v : Vec A (suc n)) : Vec A n = v.2

def Vec-Ind (A : Type) (P : (n : Nat) -> Vec A n -> Type) (b : P zero <>) 
            (c : (m : Nat) (v : Vec A m) (x : A) -> P m v -> P (suc m) (x,v)) : (n : Nat) (v : Vec A n) -> P n v = elim with
  | zero => (elim with <> => b)
  | suc (n / ih) => fn v => c n v.2 v.1 (ih v.2) 

def vrec (A B : Type) (b : B) (c : A -> B -> B) : (n : Nat) -> Vec A n -> B = elim with
  | zero => fn _ => b
  | suc (n / ih) => fn v => c v.1 (ih v.2)


def vzip (A B : Type) : (n : Nat) -> Vec A n -> Vec B n -> Vec (A * B) n = elim with
  | zero => fn _ _ => <>
  | suc (_ / ih) => fn v1 v2 => ((v1.1,v2.1),ih v1.2 v2.2)

def Fin : Nat -> Type = elim with
  | zero => Void
  | suc (_ / ih) => Sum Unit ih

def fzero (n : Nat) : Fin (suc n) = inl <>
def fsuc (n : Nat) (f : Fin n) : Fin (suc n) = inr f


def Fin-Ind (P : (n : Nat) -> Fin n -> Type) (z : (n : Nat) -> P (suc n) (fzero n)) 
            (s : (n : Nat) (f : Fin n) -> P n f -> P (suc n) (fsuc n f)) : (n : Nat) (f : Fin n) -> P n f = elim with
  | zero => (elim with)
  | suc (n / ih) => elim with
    | inl x => (elim x with <> => z n)
    | inr m => s n m (ih m)



def !! (A : Type) : (n : Nat) -> Vec A n -> Fin n -> A = elim with
  | zero => fn _ => (elim with)
  | suc (n / ih) => fn v => elim with
    | inl x => v.1
    | inr m => ih v.2 m


data (A : Type) (B : A -> Type) Sg =
  | pair (x : A) (y : B x)

def fst (A : Type) (B : A -> Type) : Sg A B -> A = elim with
  | pair x y => x

def snd (A : Type) (B : A -> Type) : (p : Sg A B) -> B (fst A B p) = elim with
  | pair x y => y

def Sg-Eta (A : Type) (B : A -> Type) : (p : Sg A B) -> Id (Sg A B) p (pair (fst A B p) (snd A B p)) = elim with
  | pair x y => refl

def split (A B : Type) : Bool -> Type = elim with tt => A | ff => B


def ProdP (A B : Type) : Type = (b : Bool) -> split A B b
def pairP (A B : Type) (x : A) (y : B) : ProdP A B = elim with
  | tt => x
  | ff => y

def fstP (A B : Type) (p : ProdP A B) : A = p tt
def sndP (A B : Type) (p : ProdP A B) : B = p ff

def ProdP-Eta (A B : Type) (p : ProdP A B) : Id (ProdP A B) p (pairP A B (fstP A B p) (sndP A B p)) =
  funextd Bool (split A B) p (pairP A B (fstP A B p) (sndP A B p)) (
    elim with tt => refl | ff => refl
  )

def SumS (A B : Type) : Type = (b : Bool) * split A B b
def inlS (A B : Type) (x : A) : SumS A B = (tt,x)
def inrS (A B : Type) (x : B) : SumS A B = (ff,x)

def Iso (A B : Type) : Type =
  (f : A -> B) *
  (g : B -> A) *
  ((x : A) -> Id A x (g (f x))) *
  ((y : B) -> Id B y (f (g y)))




def iso/*-comm (A B : Type) : Iso (A * B) (B * A) = 
  ( fn p => (p.2,p.1)
  , fn p => (p.2,p.1)
  , fn _ => refl
  , fn _ => refl
  )

def iso/Sum-comm (A B : Type) : Iso (Sum A B) (Sum B A) = 
  ( elim with inl x => inr x | inr y => inl y
  , elim with inl x => inr x | inr y => inl y
  , elim with inl _ => refl | inr _ => refl
  , elim with inl _ => refl | inr _ => refl
  )

def iso/*-ident-r (A : Type) : Iso A (A * Unit) =
  ( fn x => (x , <>) 
  , fn p => p.1 
  , fn _ => refl 
  , fn p => elim p.2 with <> => refl
  )

def iso/Sum-ident-r (A : Type) : Iso A (Sum A Void) =
  ( fn a => inl a
  , elim with inl a => a | inr v => elim v with
  , fn _ => refl
  , elim with inl a => refl | inr v => elim v with
  )

def iso/Iso-comm (A B : Type) : Iso^1 (Iso A B) (Iso B A) =
  ( fn p => (p.2.1, p.1, p.2.2.2, p.2.2.1) 
  , fn p => (p.2.1, p.1, p.2.2.2, p.2.2.1) 
  , fn _ => refl 
  , fn _ => refl
  )

def iso/*-destroy-r (A : Type) : Iso (A * Void) Void =
  ( fn p => p.2
  , elim with
  , fn p => elim p.2 with
  , elim with
  )

def iso/Bool/Unit+Unit : Iso Bool (Sum Unit Unit) =
  ( elim with tt => inl <> | ff => inr <>
  , elim with inl _ => tt | inr _ => ff
  , elim with tt => refl | ff => refl
  , elim with inl x => (elim x with <> => refl) | inr x => (elim x with <> => refl) 
  )

def iso/*/Sg (A : Type) (B : A -> Type) : Iso ((x : A) * B x) (Sg A B) = 
  ( fn p => pair p.1 p.2
  , elim with pair x y => (x,y)
  , fn _ => refl
  , elim with pair x y => refl
  )


def iso/*/ProdP (A B : Type) : Iso (A * B) (ProdP A B) =
  ( fn p => pairP A B p.1 p.2
  , fn p => (fstP (A) B p, sndP A B p) 
  , fn _ => refl
  , ProdP-Eta A B
  )


def iso/SumS/Sum (A B : Type) : Iso (SumS A B) (Sum A B) = 
  let f = uncurryd Bool (split A B) (fn _ => Sum A B) (elim with tt => fn x => inl x | ff => fn x => inr x) in
  let g : Sum A B -> SumS A B = elim with inl x => (tt,x) | inr x => (ff,x) in
  let fg : (s : Sum A B) -> Id (Sum A B) s (f (g s)) = elim with inl x => refl | inr x => refl in
  let gf = uncurryd Bool (split A B) (fn p => Id (SumS A B) p (g (f p))) 
    (elim with tt => fn n => refl | ff => fn n => refl) in
  ( f 
  , g
  , gf
  , fg
  )


def iso/Nat/ListUnit : Iso Nat (List Unit) =
  ( elim with zero => nil | suc (_ / ih) => cons <> ih
  , elim with nil => zero | cons _ (_ / ih) => suc ih
  , elim with zero => refl | suc (n / ih) => match ih with refl j => refl
  , elim with nil => refl | cons x (xs / ih) => match ih with refl j => elim x with <> => refl
  )


def iso/Nat/Nat+1 : Iso Nat (Sum Unit Nat) =
  ( elim with zero => inl <> | suc (n / ih) => inr n
  , elim with inl x => zero | inr n => suc n
  , elim with zero => refl | suc (n / ih) => refl
  , elim with inl x => (elim x with <> => refl) | inr n => refl
  )


def iso/Bool/Fin2 : Iso Bool (Fin two) = 
  ( elim with tt => inl <> | ff => inr (inl <>)
  , elim with inl _ => tt | inr x => elim x with inl _ => ff | inr v => elim v with
  , elim with tt => refl | ff => refl
  , elim with inl x => (elim x with <> => refl) | inr x => elim x with inl x => (elim x with <> => refl) | inr v => elim v with
  )




def Monoid (M : Type) : Type =
  (z : M) *
  (op : M -> M -> M) *
  Id-L M op z *
  Id-R M op z *
  Assoc M op

def Monoid-Nat-+ : Monoid Nat =
  ( zero
  , +
  , fn _ => refl
  , +-zero
  , +-assoc
  )

def Monoid-List-++ (A : Type) : Monoid (List A) =
  ( nil
  , ++ A
  , fn _ => refl
  , ++-nil A
  , ++-assoc A
  )


data U =
  | arrow (e1 e2 : U)
  | nat | bool

def El : U -> Type = elim with
  | arrow (_ / t1) (_ / t2) => t1 -> t2
  | nat => Nat
  | bool => Bool

data Exp =
  | num (n : Nat)
  | add (m n : Exp) 

def eval : Exp -> Nat = elim with
  | num n => n
  | add (_ / ih1) (_ / ih2) => + ih1 ih2

def eval-tail' : Exp -> Nat -> Nat = elim with
  | num n => fn acc => + n acc
  | add (n / ih1) (m / ih2) => fn acc => ih1 (ih2 acc) 

def eval-tail : Exp -> Nat = fn e => eval-tail' e zero


def Contr (A : Type) : Type = (x : A) * (y : A) -> Id A x y

def Prop (A : Type) : Type = (x y : A) -> Id A x y

def Set (A : Type) : Type = (x y : A) -> Prop (Id A x y)

def HLevel : Nat -> Type -> Type = elim with
  | zero  => Contr
  | suc n => elim n with
    | zero => Prop
    | suc (_ / ih) => fn A => (x y : A) -> ih (Id A x y)

def Contr->Prop (A : Type) (p : Contr A) : Prop A =
  fn x y => trans A x p.1 y (sym A p.1 x (p.2 x)) (p.2 y)


{-
def HLevel-suc (A : Type) : (n : Nat) -> HLevel n A -> HLevel (suc n) A = elim with
  | zero => fn p x y => trans A x p.1 y (sym A p.1 x (p.2 x)) (p.2 y)
  | suc n => elim n with
    | zero => fn f x y p q => 
      let id-point = f x in
      ?
    | suc (_ / ih) => ?
-}

def Contr-Unit : Contr Unit = (<>,Unit-Eta)

def Prop-Unit : Prop Unit = elim with 
  | <> => elim with <> => refl

def Set-Unit : Set Unit = elim with <> => elim with <> => fn p =>
  let P1 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn p => (q : Id Unit <> <>) -> Id (Id Unit <> <>) p q in
  let P2 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn q => Id (Id Unit <> <>) refl q in
  match p at x y p => P1 x y p with
    | refl i => elim i with <> => fn q => 
      match q at x y q => P2 x y q with
        | refl j => elim j with <> => refl

def Prop-Void : Prop Void = elim with

def Set-Void : Set Void = elim with

def HLevel-suc-Void : (n : Nat) -> HLevel (suc n) Void = elim with
  | zero  => (elim with)
  | suc n => (elim with)


def Singl (A : Type) (x : A) : Type = (y : A) * Id A x y

def Contr-Singl (A : Type) (x : A) : Contr (Singl A x) = 
  ((x,refl),fn p => match p.2 with refl w => refl)


def Functor (F : Type -> Type) : Type^1 = (A B : Type) -> (A -> B) -> F A -> F B

def Applicative (F : Type -> Type) : Type^1 =
  (pure : (A : Type) -> A -> F A) *
  (<*> : (A B : Type) -> F (A -> B) -> F A -> F B) *
  Functor F

def Monad (F : Type -> Type) : Type^1 = 
  (join : (A : Type) -> F (F A) -> F A) *
  Applicative F


def bind (F : Type -> Type) (M : Monad F) (A B : Type) (m : F A) (f : A -> F B) : F B =
  M.1 B (M.2.2.2 A (F B) f m)

def Functor-id : Functor (fn A => A) = fn _ _ f => f

def Applicative-id : Applicative (fn A => A) = (id,Functor-id,Functor-id)

def Monad-id : Monad (fn A => A) = (id,Applicative-id)

def Functor-Maybe : Functor (fn A => Maybe A) = fn A B f => elim with
  | none => none
  | some x => some (f x)

def Applicative-Maybe : Applicative (fn A => Maybe A) =
  (fn _ x => some x,fn _ _ => elim with none => fn _ => none | some f => elim with none => none | some x => some (f x),Functor-Maybe)

def Monad-Maybe : Monad (fn A => Maybe A) =
  (fn _ => elim with none => none | some x => x,Applicative-Maybe)

def Functor-List : Functor (fn A => List A) = fn A B f => elim with
  | nil => nil
  | cons x (xs / ih) => cons (f x) ih

def Applicative-List : Applicative (fn A => List A) = 
  ( fn _ x => cons x nil
  , fn A B fs xs => elim fs with
    | nil => nil
    | cons f (fs / ih) => ++ B (map A B f xs) ih
  , Functor-List
  )

def Monad-List : Monad (fn A => List A) =
  ( fn A => elim with
    | nil => nil
    | cons x (_ / ih) => ++ A x ih
  , Applicative-List
  )


data (A : Type) Dec =
  | yes (x : A)
  | no  (x : Not A)

def lower (A : Type) : Dec A -> Bool = elim with
  | yes _ => tt
  | no  _ => ff

def Dec-Id (A : Type) : Type = (x y : A) -> Dec (Id A x y)


def dec-Unit : Dec-Id Unit = elim with
  | <> => elim with <> => yes refl


def dec-Bool : Dec-Id Bool = elim with
  | tt => (elim with tt => yes refl | ff => no (fn ()))
  | ff => (elim with tt => no (fn ()) | ff => yes refl)

def eq-Bool (x y : Bool) : Bool = lower (Id Bool x y) (dec-Bool x y)

def dec-Nat : Dec-Id Nat = elim with
  | zero  => (elim with zero => yes refl | suc n => no (fn ()))
  | suc (n / ih) => 
    elim with 
      | zero => no (fn ()) 
      | suc m => elim ih m with
        | yes p => (match p with refl j => yes refl)
        | no ~p => no (fn p => ~p (cong Nat Nat pred (suc n) (suc m) p))


def eq-Nat (x y : Nat) : Bool = lower (Id Nat x y) (dec-Nat x y)

def dec-Unit : Dec-Id Unit = elim with 
  | <> => elim with <> => yes refl


def dec-* (A B : Type) : Dec A -> Dec B -> Dec (A * B) = elim with
  | yes a => (elim with
    | yes b => yes (a,b)
    | no ~b => no (fn p => ~b p.2)
  )
  | no ~a => (elim with
    | yes b => no (fn p => ~a p.1)
    | no ~b => no (fn p => ~a p.1)
  )

def dec-id-* (A B : Type) (da : Dec-Id A) (db : Dec-Id B) : Dec-Id (A * B) = fn p q =>
  elim da p.1 q.1 with
    | yes a => (elim db p.2 q.2 with
      | yes b => yes (pair-ext A B p q a b)
      | no ~b => no (fn i => ~b (pair-id-r A B p q i))
    )
    | no ~a => (elim db p.2 q.2 with
      | yes b => no (fn i => ~a (pair-id-l A B p q i))
      | no ~b => no (fn i => ~a (pair-id-l A B p q i))
    )

def eq-* (A B : Type) (da : Dec-Id A) (db : Dec-Id B) (x y : A * B): Bool = lower (Id (A * B) x y) (dec-id-* A B da db x y)

data (A B : Type) (f : A -> B) Image =
  | img (x : A) (y : B) (p : Id B y (f x))

def q : Image Nat Nat pred = img one zero refl


data (n : Nat) leqList =
  | nil
  | cons (m : Nat) (p : leq m n) (xs : leqList)

def xs : leqList (suc four) = cons one <> (cons two <> (cons zero <> nil))


def constant (A B : Type) (f : A -> B) : Type = (x y : A) -> Id B (f x) (f y)

def collapsible (A : Type) : Type = (f : A -> A) * constant A A f

def path-collapsible (A : Type) : Type = (x y : A) -> collapsible (Id A x y)

def Set->PC (A : Type) (s : Set A) : path-collapsible A = fn x y =>
  (fn x => x,s x y)

{-
def PC->Set (A : Type) (pc : path-collapsible A) : Set A = fn x y p q =>
  ?
-}

def EM : Type^1 = (A : Type) -> Dec A
def DNE : Type^1 = (A : Type) -> Not (Not A) -> A

def EM->DNE : EM -> DNE = fn em A =>
  elim em A with
    | yes a => fn _ => a
    | no ~a => fn ~~a => elim ~~a ~a with

def Stable (A : Type) : Type = Not (Not A) -> A

def Not-Stable (A : Type) : Stable (Not A) = fn ~~~a a =>
  ~~~a (fn ~a => ~a a)

def *-Stable (A B : Type) (sa : Stable A) (sb : Stable B) : Stable (A * B) = fn ~~a*b =>
  (sa (fn ~a => ~~a*b (fn p => ~a p.1)), sb (fn ~b => ~~a*b (fn p => ~b p.2)))

def Dec->Stable (A : Type) : Dec A -> Stable A = elim with
  | yes a => fn _ => a
  | no ~a => fn ~~a => elim ~~a ~a with

def Functor-NotNot : Functor (fn A => Not (Not A)) =
  fn A B f ~~a ~b => ~~a (fn a => ~b (f a))

def Applicative-NotNot : Applicative (fn A => Not (Not A)) =
  ( fn A a ~a => ~a a
  , fn A B ~~A->B ~~a ~b => ~~A->B (fn f => ~~a (fn a => ~b (f a)))
  , Functor-NotNot
  )

def Monad-NotNot : Monad (fn A => Not (Not A)) =
  ( fn A ~~~~a ~a => ~~~~a (fn ~~a => ~~a ~a)
  , Applicative-NotNot
  )

def Injection (A B : Type) (f : A -> B) : Type = (x y : A) -> Id B (f x) (f y) -> Id A x y

def Countable (A : Type) : Type = (f : A -> Nat) * Injection A Nat f

def Countable-Nat : Countable Nat =
  ( fn x => x
  , fn x y p => p
  )


def Finite (A : Type) : Type^1 = (n : Nat) * Iso A (Fin n)

def Finite-Bool : Finite Bool = (two , iso/Bool/Fin2)

def Finite-Maybe (A : Type) (f : Finite A) : Finite (Maybe A) =
  ( suc (f.1)
  , elim with none => inl <> | some x => inr (f.2.1 x)
  , elim with inl x => none | inr x => some (f.2.2.1 x)
  , elim with none => refl | some x => match f.2.2.2.1 x with refl i => refl
  , elim with inl x => (elim x with <> => refl) | inr x => match f.2.2.2.2 x with refl i => refl
  )

data Void' =
  | V (x : Void')

def Void'-Rec (A : Type) : Void' -> A = elim with
  | V (_ / ih) => ih

def iso/Void/Void' : Iso Void Void' =
  let f : Void -> Void' = elim with in
  let g : Void' -> Void = elim with V (_ / ih) => ih in
 ( f
 , g
 , elim with
 , fn y => Void'-Rec (Id Void' y (f (g y))) y
 )


{-
This definitely should not be allowed lol

data sus =
  | C (x : Type^1)
-}



data Ty =
  | ar (a b : Ty)
  | bool
  | nat

def dec-Ty : Dec-Id Ty = elim with
  | ar (a / iha) (b / ihb) => (elim with
    | ar a' b' => (elim iha a' with
      | yes pa => (elim ihb b' with
        | yes pb => match pa with refl i => match pb with refl j => yes refl
        | no ~pb => no (fn p => ~pb (cong Ty Ty (elim with ar _ b => b | bool => bool | nat => nat) (ar a b) (ar a' b') p))
      )
      | no ~pa => no (fn p => ~pa (cong Ty Ty (elim with ar a _ => a | bool => bool | nat => nat) (ar a b) (ar a' b') p))
    )
    | bool => no (fn ())
    | nat => no (fn ())
  )
  | bool => (elim with
    | bool => yes refl
    | ar a b => no (fn ())
    | nat => no (fn ())
  )
  | nat => (elim with
    | nat => yes refl
    | ar _ _ => no (fn ())
    | bool => no (fn ())
  )

def eq-Ty (t1 t2 : Ty) : Bool = lower (Id Ty t1 t2) (dec-Ty t1 t2)

data Tm =
  | var (n : Nat)
  | tt
  | ff
  | if (b e1 e2 : Tm)
  | zero
  | suc (n : Tm)
  | rec (e z s : Tm)
  | lam (t : Ty) (e : Tm)
  | ap (f e : Tm)

def synth : Tm -> List Ty -> Maybe Ty = let bind = bind (fn A => Maybe A) Monad-Maybe Ty Ty in elim with
  | var n => fn ctx => get Ty ctx n
  | tt => fn _ => some bool
  | ff => fn _ => some bool
  | if (b / bty) (e1 / e1ty) (e2 / e2ty) => fn ctx => bind (bty ctx) (elim with
    | ar _ _ => none
    | nat => none
    | bool => bind (e1ty ctx) (fn t1 => bind (e2ty ctx) (fn t2 =>
      elim eq-Ty t1 t2 with
        | tt => some t1
        | ff => none
    ))
  )
  | lam t1 (e / ih) => fn ctx =>
    bind (ih (cons t1 ctx)) (fn t2 =>
      some (ar t1 t2)
    )
  | ap (f / fty) (e / ety) => fn ctx => bind (fty ctx) (elim with
    | bool => none
    | nat => none
    | ar a b => bind (ety ctx) (fn t =>
      elim eq-Ty a t with
        | tt => some b
        | ff => none
    )
  )
  | zero => fn _ => some nat
  | suc (n / nty) => fn ctx => bind (nty ctx) (elim with
    | nat => some nat
    | bool => none
    | ar _ _ => none
  ) 
  | rec (n / nty) (z / zty) (s / sty) => fn ctx => bind (nty ctx) (elim with
    | bool => none
    | ar _ _ => none
    | nat => 
      bind (zty ctx) (fn t =>
      bind (sty (cons t ctx)) (fn t' =>
        elim eq-Ty t t' with
          | tt => some t
          | ff => none 
      )
    )
  )
  

def tm1 : Tm = lam bool (lam bool (var zero))
def tm2 : Tm = lam nat (lam nat (rec (var one) (var zero) (suc (var zero))))

