def id (A : Type) (x : A) : A = x

def J (A : Type) (P : (x y : A) -> Id A x y -> Type) (f : (x : A) -> P x x refl) (x y : A) (p : Id A x y) : P x y p =
  match p with
    | refl i => f i

axiom K : (A : Type) (x : A) (P : Id A x x -> Type) (r : P refl) (p : Id A x x) -> P p

axiom funext : (A B : Type) (f g : A -> B) -> ((x : A) -> Id B (f x) (g x)) -> Id (A -> B) f g

axiom funextd : (A : Type) (B : A -> Type) (f g : (x : A) -> B x) -> ((x : A) -> Id (B x) (f x) (g x)) -> Id ((x : A) -> B x) f g

def sym (A : Type) (x y : A) (p : Id A x y) : Id A y x =
  match p with
    | refl _ => refl

def trans (A : Type) (x y z : A) (p : Id A x y) : Id A y z -> Id A x z =
  match p with
    | refl _ => fn x => x

def cong (A B : Type) (f : A -> B) (x y : A) (p : Id A x y) : Id B (f x) (f y) =
  match p with
    | refl _ => refl

def subst (A : Type) (x y : A) (p : Id A x y) (P : A -> Type) : P x -> P y =
  match p with
    | refl _ => fn z => z

def coe (A B : Type) (p : Id Type A B) : A -> B =
  match p with
    | refl _ => Î» x => x

def trans-refl (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x y y p refl) =
  match p with
    | refl _ => refl

def refl-trans (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (trans A x x y refl p) =
  match p with
    | refl _ => refl

def sym-sym (A : Type) (x y : A) (p : Id A x y) : Id (Id A x y) p (sym A y x (sym A x y p)) =
  match p with
    | refl _ => refl

def coe-refl (A : Type) (x : A) : Id A (coe A A refl x) x = refl


def Comm (A : Type) (op : A -> A -> A) : Type = (x y : A) -> Id A (op x y) (op y x)

def Assoc (A : Type) (op : A -> A -> A) : Type = (x y z : A) -> Id A (op (op x y) z) (op x (op y z))

def Id-L (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op z x)

def Id-R (A : Type) (op : A -> A -> A) (z : A) : Type = (x : A) -> Id A x (op x z)


def curry (A B C : Type) (f : A * B -> C) : A -> B -> C = fn x y => f (x,y)
def curryd (A : Type) (B : A -> Type) (C : (x : A) -> B x -> Type) (f : (p : (x : A) * B x) -> C p.1 p.2) : (x : A) (y : B x) -> C x y = fn x y => f (x,y)

def uncurry (A B C : Type) (f : A -> B -> C) : A * B -> C = fn p => f p.1 p.2
def uncurryd (A : Type) (B : A -> Type) (C : (x : A) -> B x -> Type) (f : (x : A) (y : B x) -> C x y) : (p : (x : A) * B x) -> C p.1 p.2 = fn p => f p.1 p.2

data Void

def Void-Ind (P : Void -> Type) : (x : Void) -> P x =
  elim with

def Not (A : Type) : Type = A -> Void

data Unit =
  | <>

def Unit-Ind (P : Unit -> Type) (p : P <>) : (x : Unit) -> P x = elim with
  | <> => p

def Unit-Eta : (x : Unit) -> Id Unit <> x = elim with
  | <> => refl


data Bool =
  | tt
  | ff

def no-confusion-Bool : Not (Id Bool tt ff) = fn p =>
  subst Bool tt ff p (elim with tt => Unit | ff => Void) <>

def Bool-Ind (P : Bool -> Type) (t : P tt) (f : P ff) : (b : Bool) -> P b = elim with
  | tt => t
  | ff => f

def not : Bool -> Bool = elim with
  | tt => ff
  | ff => tt


def and (a b : Bool) : Bool = elim a with
  | tt => b
  | ff => ff

def or (a b : Bool) : Bool = elim a with
  | tt => tt
  | ff => b


def not-not : (b : Bool) -> Id Bool b (not (not b)) = elim with
  | tt => refl
  | ff => refl

def demorgan1 (a b : Bool) : Id Bool (not (and a b)) (or (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

def demorgan2 (a b : Bool) : Id Bool (not (or a b)) (and (not a) (not b)) = elim a with
  | tt => refl
  | ff => refl

data Nat =
  | zero
  | suc (n : Nat)

def one : Nat = suc zero
def two : Nat = suc one
def three : Nat = suc two
def four : Nat = suc three

def Nat-Ind (P : Nat -> Type) (z : P zero) (s : (m : Nat) -> P m -> P (suc m)) : (n : Nat) -> P n = elim with
  | zero => z
  | suc (n / ih) => s n ih

def no-confusion-Nat (n : Nat) : Not (Id Nat zero (suc n)) = fn p =>
  subst Nat zero (suc n) p (elim with zero => Unit | suc _ => Void) <>

def pred : Nat -> Nat = elim with
  | zero => zero
  | suc n => n

def + (n m : Nat) : Nat = elim n with
  | zero => m
  | suc (_ / ih) => suc ih

def mult (n m : Nat) : Nat = elim n with
  | zero => zero
  | suc (_ / ih) => + m ih


def +-assoc : Assoc Nat + = fn n m p => elim n with
  | zero => refl
  | suc (_ / ih) => match ih with
    | refl _ => refl

def +-zero : Id-R Nat + zero = elim with
  | zero => refl
  | suc (_ / ih) => match ih with
      | refl _ => refl

def +-suc (n m : Nat) : Id Nat (suc (+ n m)) (+ n (suc m)) = elim n with
  | zero => refl
  | suc (n' / ih) => 
    match ih with
      | refl z => refl

def +-comm : Comm Nat + = fn n m => elim n with
  | zero => +-zero m
  | suc (n / ih) => trans Nat (suc (+ n m)) (suc (+ m n)) (+ m (suc n)) 
    (cong Nat Nat (fn x => suc x) (+ n m) (+ m n) ih) 
    (+-suc m n)


def leq : Nat -> Nat -> Type = elim with
  | zero => fn _ => Unit
  | suc (_ / ih) => elim with
    | zero => Void
    | suc n => ih n

def leq-zero (n : Nat) : leq zero n = <>
def leq-suc (m n : Nat) (p : leq m n) : leq (suc m) (suc n) = p



def id-elim : Nat -> Nat = elim with
  | zero => zero
  | suc n => suc n

def id-elim-id : (n : Nat) -> Id Nat (id Nat n) (id-elim n) = elim with
  | zero => refl
  | suc _ => refl

def suc-Inj (n m : Nat) : Id Nat (suc n) (suc m) -> Id Nat n m =
  cong Nat Nat pred (suc n) (suc m)


data (A B : Type) Sum =
  | inl (x : A)
  | inr (y : B)

def Sum-Ind (A B : Type) (P : Sum A B -> Type) (l : (x : A) -> P (inl x)) (r : (x : B) -> P (inr x)) : (x : Sum A B) -> P x = elim with
  | inl x => l x
  | inr y => r y

data (A : Type) Maybe =
  | none
  | some (x : A)

data (A : Type) List =
  | nil
  | cons (x : A) (xs : List)

def List-Ind (A : Type) (P : List A -> Type) (n : P nil) (c : (x : A) (xs : List A) -> P xs -> P (cons x xs)) : (xs : List A) -> P xs = elim with
  | nil => n
  | cons x (xs / ih) => c x xs ih

def ++ (A : Type) (xs ys : List A) : List A = elim xs with
  | nil => ys
  | cons x (_ / ih) => cons x ih

def hd (A : Type) : List A -> Maybe A = elim with
  | nil => none
  | cons x _ => some x

def tl (A : Type) : List A -> List A = elim with
  | nil => nil
  | cons _ xs => xs

def ++-assoc (A : Type) : Assoc (List A) (++ A) = fn xs ys zs => elim xs with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl

def ++-nil (A : Type) : Id-R (List A) (++ A) nil = elim with
  | nil => refl
  | cons x (xs / ih) => match ih with
    | refl _ => refl


data (A : Type) Tree =
  | empty
  | node (l : Tree) (x : A) (r : Tree)

def tree-rev (A : Type) : Tree A -> Tree A = elim with
  | empty => empty
  | node (l / ihl) x (r / ihr) => node ihr x ihl

def PType : Type^1 = (A : Type) * A

def PUnit : PType = (Unit,<>)
def PNat : PType = (Nat,zero)

def Loop (P : PType) : PType =
  (Id P.1 P.2 P.2, refl)

def LoopN (P : PType) : Nat -> PType = elim with
  | zero => P
  | suc (_ / ih) => Loop ih

def PType-not-Void (P : PType) : Not^1 (Id Type P.1 Void) = fn p =>
  coe P.1 Void p P.2

def pair-ext (A B : Type) (x y : A * B) (p : Id A x.1 y.1) (q : Id B x.2 y.2) : Id (A * B) x y =
  match p with
    | refl w => match q with
      | refl h => refl

def Vec (A : Type) : Nat -> Type = elim with
  | zero => Unit
  | suc (_ / ih) => A * ih

def vnil (A : Type) : Vec A zero = <>
def vcons (A : Type) (x : A) (n : Nat) (xs : Vec A n) : Vec A (suc n) = (x,xs)

def vhd (A : Type) (n : Nat) (v : Vec A (suc n)) : A = v.1
def vtl (A : Type) (n : Nat) (v : Vec A (suc n)) : Vec A n = v.2

def Vec-Ind (A : Type) (P : (n : Nat) -> Vec A n -> Type) (b : P zero <>) 
            (c : (m : Nat) (v : Vec A m) (x : A) -> P m v -> P (suc m) (x,v)) : (n : Nat) (v : Vec A n) -> P n v = elim with
  | zero => (elim with <> => b)
  | suc (n / ih) => fn v => c n v.2 v.1 (ih v.2) 

def vrec (A B : Type) (b : B) (c : A -> B -> B) : (n : Nat) -> Vec A n -> B = elim with
  | zero => fn _ => b
  | suc (n / ih) => fn v => c v.1 (ih v.2)


def vzip (A B : Type) : (n : Nat) -> Vec A n -> Vec B n -> Vec (A * B) n = elim with
  | zero => fn _ _ => <>
  | suc (_ / ih) => fn v1 v2 => ((v1.1,v2.1),ih v1.2 v2.2)


data (A : Type) (B : A -> Type) Sg =
  | pair (x : A) (y : B x)

def fst (A : Type) (B : A -> Type) : Sg A B -> A = elim with
  | pair x y => x

def snd (A : Type) (B : A -> Type) : (p : Sg A B) -> B (fst A B p) = elim with
  | pair x y => y

def Sg-Eta (A : Type) (B : A -> Type) : (p : Sg A B) -> Id (Sg A B) p (pair (fst A B p) (snd A B p)) = elim with
  | pair x y => refl

def split (A B : Type) : Bool -> Type = elim with tt => A | ff => B


def ProdP (A B : Type) : Type = (b : Bool) -> split A B b
def pairP (A B : Type) (x : A) (y : B) : ProdP A B = elim with
  | tt => x
  | ff => y

def fstP (A B : Type) (p : ProdP A B) : A = p tt
def sndP (A B : Type) (p : ProdP A B) : B = p ff

def ProdP-Eta (A B : Type) (p : ProdP A B) : Id (ProdP A B) p (pairP A B (fstP A B p) (sndP A B p)) =
  funextd Bool (split A B) p (pairP A B (fstP A B p) (sndP A B p)) (
    elim with tt => refl | ff => refl
  )

def SumS (A B : Type) : Type = (b : Bool) * split A B b
def inlS (A B : Type) (x : A) : SumS A B = (tt,x)
def inrS (A B : Type) (x : B) : SumS A B = (ff,x)

def Iso (A B : Type) : Type^1 =
  (f : A -> B) *
  (g : B -> A) *
  ((x : A) -> Id A x (g (f x))) *
  ((y : B) -> Id B y (f (g y)))




def iso/*-comm (A B : Type) : Iso (A * B) (B * A) = 
  ( fn p => (p.2,p.1)
  , fn p => (p.2,p.1)
  , fn _ => refl
  , fn _ => refl
  )

def iso/Sum-comm (A B : Type) : Iso (Sum A B) (Sum B A) = 
  ( elim with inl x => inr x | inr y => inl y
  , elim with inl x => inr x | inr y => inl y
  , elim with inl _ => refl | inr _ => refl
  , elim with inl _ => refl | inr _ => refl
  )

def iso/*-ident-r (A : Type) : Iso A (A * Unit) =
  ( fn x => (x , <>) 
  , fn p => p.1 
  , fn _ => refl 
  , fn p => elim p.2 with <> => refl
  )

def iso/Sum-ident-r (A : Type) : Iso A (Sum A Void) =
  ( fn a => inl a
  , elim with inl a => a | inr v => elim v with
  , fn _ => refl
  , elim with inl a => refl | inr v => elim v with
  )

def iso/Iso-comm (A B : Type) : Iso^1 (Iso A B) (Iso B A) =
  ( fn p => (p.2.1, p.1, p.2.2.2, p.2.2.1) 
  , fn p => (p.2.1, p.1, p.2.2.2, p.2.2.1) 
  , fn _ => refl 
  , fn _ => refl
  )

def iso/*-destroy-r (A : Type) : Iso (A * Void) Void =
  ( fn p => p.2
  , elim with
  , fn p => elim p.2 with
  , elim with
  )

def iso/Bool/Unit+Unit : Iso Bool (Sum Unit Unit) =
  ( elim with tt => inl <> | ff => inr <>
  , elim with inl _ => tt | inr _ => ff
  , elim with tt => refl | ff => refl
  , elim with inl x => (elim x with <> => refl) | inr x => (elim x with <> => refl) 
  )

def iso/*/Sg (A : Type) (B : A -> Type) : Iso ((x : A) * B x) (Sg A B) = 
  ( fn p => pair p.1 p.2
  , elim with pair x y => (x,y)
  , fn _ => refl
  , elim with pair x y => refl
  )


def iso/*/ProdP (A B : Type) : Iso (A * B) (ProdP A B) =
  ( fn p => pairP A B p.1 p.2
  , fn p => (fstP (A) B p, sndP A B p) 
  , fn _ => refl
  , ProdP-Eta A B
  )


def iso/Sum/SumS (A B : Type) : Iso (SumS A B) (Sum A B) = 
  let f = uncurryd Bool (split A B) (fn _ _ => Sum A B) (elim with tt => fn x => inl x | ff => fn x => inr x) in
  let g : Sum A B -> SumS A B = elim with inl x => (tt,x) | inr x => (ff,x) in
  let fg : (s : Sum A B) -> Id (Sum A B) s (f (g s)) = elim with inl x => refl | inr x => refl in
  let gf = uncurryd Bool (split A B) (fn x1 x2 => Id (SumS A B) (x1,x2) (g (f (x1,x2)))) 
    (elim with tt => fn n => refl | ff => fn n => refl) in
  ( f 
  , g
  , gf
  , fg
  )


def Monoid (M : Type) : Type =
  (z : M) *
  (op : M -> M -> M) *
  Id-L M op z *
  Id-R M op z *
  Assoc M op

def Monoid-Nat-+ : Monoid Nat =
  ( zero
  , +
  , fn _ => refl
  , +-zero
  , +-assoc
  )

def Monoid-List-++ (A : Type) : Monoid (List A) =
  ( nil
  , ++ A
  , fn _ => refl
  , ++-nil A
  , ++-assoc A
  )


data U =
  | arrow (e1 e2 : U)
  | nat | bool

def El : U -> Type = elim with
  | arrow (_ / t1) (_ / t2) => t1 -> t2
  | nat => Nat
  | bool => Bool

data Exp =
  | num (n : Nat)
  | add (m n : Exp) 

def eval : Exp -> Nat = elim with
  | num n => n
  | add (_ / ih1) (_ / ih2) => + ih1 ih2

def eval-tail' : Exp -> Nat -> Nat = elim with
  | num n => fn acc => + n acc
  | add (n / ih1) (m / ih2) => fn acc => ih1 (ih2 acc) 

def eval-tail : Exp -> Nat = fn e => eval-tail' e zero


def Contr (A : Type) : Type = (x : A) * (y : A) -> Id A x y

def Prop (A : Type) : Type = (x y : A) -> Id A x y

def Set (A : Type) : Type = (x y : A) -> Prop (Id A x y)

def HLevel : Nat -> Type -> Type = elim with
  | zero  => Contr
  | suc n => elim n with
    | zero => Prop
    | suc (_ / ih) => fn A => (x y : A) -> ih (Id A x y)



{-
def HLevel-suc (A : Type) : (n : Nat) -> HLevel n A -> HLevel (suc n) A = elim with
  | zero => fn p x y => trans A x p.1 y (sym A p.1 x (p.2 x)) (p.2 y)
  | suc n => elim n with
    | zero => fn f x y p q => 
      let id-point = f x in
      ?
    | suc (_ / ih) => ?
-}

def Contr-Unit : Contr Unit = (<>,Unit-Eta)

def Prop-Unit : Prop Unit = elim with 
  | <> => elim with <> => refl

def Set-Unit : Set Unit = elim with <> => elim with <> => fn p =>
  let P1 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn p => (q : Id Unit <> <>) -> Id (Id Unit <> <>) p q in
  let P2 : (x y : Unit) -> Id Unit x y -> Type = elim with <> => elim with <> => fn q => Id (Id Unit <> <>) refl q in
  match p at x y p => P1 x y p with
    | refl i => elim i with <> => fn q => 
      match q at x y q => P2 x y q with
        | refl j => elim j with <> => refl

def Prop-Void : Prop Void = elim with

def Set-Void : Set Void = elim with

def HLevel-suc-Void : (n : Nat) -> HLevel (suc n) Void = elim with
  | zero  => (elim with)
  | suc n => (elim with)


def Singl (A : Type) (x : A) : Type = (y : A) * Id A x y

def Contr-Singl (A : Type) (x : A) : Contr (Singl A x) = 
  ((x,refl),fn p => match p.2 with refl w => refl)


def Functor (F : Type -> Type) : Type^1 = (A B : Type) -> (A -> B) -> F A -> F B

def Applicative (F : Type -> Type) : Type^1 =
  (pure : (A : Type) -> A -> F A) *
  (<*> : (A B : Type) -> F (A -> B) -> F A -> F B) *
  Functor F

def Monad (F : Type -> Type) : Type^1 = 
  (join : (A : Type) -> F (F A) -> F A) *
  Applicative F


def bind (F : Type -> Type) (M : Monad F) (A B : Type) (m : F A) (f : A -> F B) : F B =
  M.1 B (M.2.2.2 A (F B) f m)


def Functor-id : Functor (id^1 Type) = fn A B f => f

def Applicative-id : Applicative (id^1 Type) = (id,Functor-id,Functor-id)

def Monad-id : Monad (id^1 Type) = (id,Applicative-id)

def Functor-Maybe : Functor (fn A => Maybe A) = fn A B f => elim with
  | none => none
  | some x => some (f x)

def Applicative-Maybe : Applicative (fn A => Maybe A) =
  (fn _ x => some x,fn _ _ => elim with none => fn _ => none | some f => elim with none => none | some x => some (f x),Functor-Maybe)

def Monad-Maybe : Monad (fn A => Maybe A) =
  (fn _ => elim with none => none | some x => x,Applicative-Maybe)

